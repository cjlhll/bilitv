# 页面位置和遥控器焦点持久化分析

## 概述

本文档详细分析了Android TV项目中页面滚动位置和遥控器焦点的持久化机制，包括实现方式、使用示例和架构设计。

---

## 一、页面滚动位置保存机制

### 1.1 实现方式：两种策略并存

项目采用了两种不同的滚动状态管理策略：

#### 策略A：ViewModel保存（UGC页面）

**核心特点**：滚动状态保存在ViewModel中，切换Tab时滚动位置会保留

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/ugc/UgcViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/ugc/UgcCommon.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/UgcContent.kt`

**具体实现**：

```kotlin
// UgcViewModel.kt
class UgcViewModel(private val ugcRepository: UgcRepository) : ViewModel() {
    private val _ugcScaffoldStateMap = mutableMapOf<UgcTopNavItem, UgcScaffoldState>()
    val ugcScaffoldStateMap: Map<UgcTopNavItem, UgcScaffoldState> get() = _ugcScaffoldStateMap

    fun addUgcScaffoldState(item: UgcTopNavItem, state: UgcScaffoldState) {
        _ugcScaffoldStateMap[item] = state
    }
}
```

```kotlin
// UgcCommon.kt
data class UgcScaffoldState(
    val lazyGridState: LazyGridState,  // 滚动状态保存在ViewModel中
    val ugcType: UgcTypeV2,
    val ugcItems: MutableList<UgcItem> = mutableStateListOf<UgcItem>(),
    var nextPage: UgcFeedPage = UgcFeedPage(),
    var hasMore: Boolean = true,
    var updating: Boolean = false
)
```

```kotlin
// UgcContent.kt
AnimatedContent(
    targetState = selectedTab,
    label = "ugc animated content",
    transitionSpec = {
        // 动画配置
    }
) { screen ->
    // 预加载相邻Tab的状态
    val range = (screen.ordinal)..minOf(screen.ordinal + 2, ugcTopNavItems.size - 1)
    for (i in range) {
        val item = ugcTopNavItems[i]
        if (item !in ugcViewModel.ugcScaffoldStateMap) {
            Log.d("UgcContent", "rememberUgcScaffoldState: $item")
            ugcViewModel.addUgcScaffoldState(
                item, UgcScaffoldState(
                    lazyGridState = rememberLazyGridState(),  // 在ViewModel中保存
                    ugcType = item.ugcTypeV2
                )
            )
        }
    }

    // 从ViewModel获取状态
    UgcRegionScaffold(
        state = ugcViewModel.ugcScaffoldStateMap[screen]!!,
        // ...
    )
}
```

**使用示例**：

```kotlin
// 在UgcRegionScaffold中使用保存的滚动状态
@Composable
fun UgcRegionScaffold(
    state: UgcScaffoldState,
    // ...
) {
    LazyVerticalGrid(
        columns = GridCells.Fixed(4),
        state = state.lazyGridState,  // 使用ViewModel中的滚动状态
        modifier = Modifier
            .fillMaxSize()
            .focusRestorer(focusRequester),
        content = {
            // 视频卡片列表
        }
    )
}
```

#### 策略B：remember创建（Home页面）

**核心特点**：滚动状态在Composable中通过remember创建，切换Tab时滚动位置会丢失

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/home/RecommendScreen.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/home/PopularScreen.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/home/DynamicsScreen.kt`

**具体实现**：

```kotlin
// RecommendScreen.kt
@Composable
fun RecommendScreen(
    viewModel: RecommendViewModel = viewModel()
) {
    val recommendVideoList by viewModel.recommendVideoList.collectAsState()
    val loading by viewModel.loading.collectAsState()

    // 使用remember创建滚动状态（切换Tab时会丢失）
    val gridState = rememberLazyGridState()

    if (loading) {
        LoadingScreen()
    } else {
        LazyVerticalGrid(
            columns = GridCells.Fixed(4),
            state = gridState,  // 滚动状态在Composable中创建
            modifier = Modifier
                .fillMaxSize()
                .focusRestorer(focusRequester),
            contentPadding = PaddingValues(12.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
        ) {
            items(
                items = recommendVideoList,
                key = { it.id }
            ) { video ->
                VideoCard(
                    video = video,
                    onClick = { /* 点击事件 */ }
                )
            }
        }
    }
}
```

```kotlin
// PopularScreen.kt - 同样的实现模式
@Composable
fun PopularScreen(
    viewModel: PopularViewModel = viewModel()
) {
    val popularVideoList by viewModel.popularVideoList.collectAsState()
    val loading by viewModel.loading.collectAsState()

    // 使用remember创建滚动状态
    val gridState = rememberLazyGridState()

    if (loading) {
        LoadingScreen()
    } else {
        LazyVerticalGrid(
            columns = GridCells.Fixed(4),
            state = gridState,
            modifier = Modifier
                .fillMaxSize()
                .focusRestorer(focusRequester),
            contentPadding = PaddingValues(12.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
        ) {
            items(
                items = popularVideoList,
                key = { it.id }
            ) { video ->
                VideoCard(
                    video = video,
                    onClick = { /* 点击事件 */ }
                )
            }
        }
    }
}
```

### 1.2 关键区别对比

| 特性 | UGC页面（ViewModel） | Home页面（remember） |
|------|---------------------|---------------------|
| 滚动状态保存位置 | ViewModel | Composable |
| 切换Tab时滚动位置 | ✅ 保留 | ❌ 丢失 |
| 实现复杂度 | 较高 | 较低 |
| 内存占用 | 较高 | 较低 |
| 适用场景 | 需要保持滚动位置的页面 | 可接受滚动位置重置的页面 |

### 1.3 AnimatedContent的影响

所有主页面都使用AnimatedContent进行Tab切换：

```kotlin
// HomeContent.kt
AnimatedContent(
    targetState = selectedTab,
    label = "home animated content",
    transitionSpec = {
        val coefficient = 10
        if (reorderedItems.indexOf(targetState) < reorderedItems.indexOf(initialState)) {
            fadeIn() + slideInHorizontally { -it / coefficient } togetherWith
                    fadeOut() + slideOutHorizontally { it / coefficient }
        } else {
            fadeIn() + slideInHorizontally { it / coefficient } togetherWith
                    fadeOut() + slideOutHorizontally { -it / coefficient }
        }
    }
) { screen ->
    when (screen) {
        HomeTopNavItem.Recommend -> RecommendScreen()
        HomeTopNavItem.Popular -> PopularScreen()
        HomeTopNavItem.Dynamics -> DynamicsScreen()
    }
}
```

**AnimatedContent的工作原理**：
- 切换时会销毁旧的Composable
- 创建新的Composable
- 使用remember创建的状态会丢失
- ViewModel中的状态会保留

---

## 二、遥控器焦点持久化机制

### 2.1 主要实现：focusRestorer

**核心特点**：自动记录和恢复焦点位置，适用于TV遥控器的焦点导航场景

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/component/TopNav.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/component/videocard/VideosRow.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/VideoInfoScreen.kt`

**具体实现**：

#### 示例1：TopNav组件

```kotlin
// TopNav.kt
@Composable
fun TopNav(
    modifier: Modifier = Modifier,
    items: List<TopNavItem>,
    isLargePadding: Boolean,
    onSelectedChanged: (TopNavItem) -> Unit = {},
    onClick: (TopNavItem) -> Unit = {}
) {
    val focusRequester = remember { FocusRequester() }

    var selectedNav by remember { mutableStateOf(items.first()) }
    var selectedTabIndex by remember { mutableIntStateOf(0) }

    Row(
        modifier = modifier
            .fillMaxWidth()
            .padding(12.dp, verticalPadding),
        horizontalArrangement = Arrangement.Center
    ) {
        TabRow(
            modifier = Modifier
                .focusRestorer(focusRequester),  // 自动恢复焦点
            selectedTabIndex = selectedTabIndex,
            separator = { Spacer(modifier = Modifier.width(12.dp)) },
        ) {
            items.forEachIndexed { index, tab ->
                NavItemTab(
                    modifier = Modifier
                        .ifElse(index == 0, Modifier.focusRequester(focusRequester)),
                    selected = selectedNav == tab,
                    onClick = {
                        selectedNav = tab
                        selectedTabIndex = index
                        onSelectedChanged(tab)
                        onClick(tab)
                    },
                    label = { Text(tab.label) }
                )
            }
        }
    }
}
```

#### 示例2：VideosRow组件

```kotlin
// VideosRow.kt
@Composable
fun VideosRow(
    title: String,
    videos: List<UgcItem>,
    onVideoClick: (UgcItem) -> Unit,
    modifier: Modifier = Modifier
) {
    val focusRequester = remember { FocusRequester() }
    var rowHeight by remember { mutableStateOf(0.dp) }
    val density = LocalDensity.current

    Column(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 12.dp)
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.titleMedium,
            modifier = Modifier.padding(vertical = 8.dp)
        )

        LazyRow(
            modifier = Modifier
                .padding(top = 15.dp)
                .focusRestorer(focusRequester)  // 自动恢复焦点
                .onGloballyPositioned {
                    rowHeight = with(density) {
                        it.size.height.toDp()
                    }
                },
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            contentPadding = PaddingValues(horizontal = 12.dp),
        ) {
            items(
                items = videos,
                key = { it.id }
            ) { video ->
                VideoCard(
                    video = video,
                    onClick = { onVideoClick(video) },
                    modifier = Modifier
                        .width(220.dp)
                        .height(rowHeight)
                )
            }
        }
    }
}
```

#### 示例3：VideoInfoScreen

```kotlin
// VideoInfoScreen.kt
@Composable
fun VideoInfoScreen(
    aid: Long,
    fromSeason: Boolean = false,
    fromController: Boolean = false,
    proxyArea: ProxyArea = ProxyArea.MainLand
) {
    val viewModel: VideoInfoViewModel = viewModel()
    val videoInfo by viewModel.videoInfo.collectAsState()
    val focusRequester = remember { FocusRequester() }

    LaunchedEffect(aid) {
        viewModel.loadVideoInfo(aid, proxyArea)
    }

    if (videoInfo == null) {
        LoadingScreen()
    } else {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .focusRestorer(focusRequester),  // 自动恢复焦点
            contentPadding = PaddingValues(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // 视频信息内容
        }
    }
}
```

**focusRestorer的工作原理**：
1. 当焦点进入该区域时，自动记录当前焦点位置
2. 当焦点离开该区域后再次返回时，自动恢复到之前的位置
3. 适用于TV遥控器的焦点导航场景
4. 无需手动管理焦点状态

### 2.2 备用实现：FocusGroup（已弃用）

**核心特点**：使用rememberSaveable保存焦点状态，能够跨Activity重建保持

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/component/FocusGroup.kt`

**具体实现**：

```kotlin
// FocusGroup.kt
@Deprecated("Use focusRestorer instead")
@Composable
fun FocusGroup(
    modifier: Modifier = Modifier,
    content: @Composable FocusGroupScope.() -> Unit
) {
    val focusGroupKeyHash = remember { System.identityHashCode(this) }

    // 使用rememberSaveable保存焦点状态
    val previousFocusedItemHash: MutableState<Int?> = rememberSaveable(
        key = focusGroupKeyHash.toString()
    ) {
        mutableStateOf(null)
    }

    val focusManager = LocalFocusManager.current

    DisposableEffect(Unit) {
        val observer = FocusObserver { from, to ->
            val currentFocusHash = to?.hashCode()
            if (currentFocusHash != null && currentFocusHash != previousFocusedItemHash.value) {
                previousFocusedItemHash.value = currentFocusHash
            }
        }
        focusManager.addObserver(observer)
        onDispose {
            focusManager.removeObserver(observer)
        }
    }

    FocusGroupScopeImpl(
        previousFocusedItemHash = previousFocusedItemHash,
        focusManager = focusManager
    ).apply {
        Column(
            modifier = modifier
                .onFocusChanged {
                    if (it.isFocused && previousFocusedItemHash.value != null) {
                        // 恢复焦点
                    }
                }
        ) {
            content()
        }
    }
}

@Composable
private fun FocusGroupScopeImpl.restorableFocus(
    focusId: String,
    content: @Composable () -> Unit
) {
    val focusRequester = remember { FocusRequester() }
    val isFocused by focusRequester.isFocused.collectAsState()

    LaunchedEffect(isFocused) {
        if (isFocused) {
            previousFocusedItemHash.value = focusId.hashCode()
        }
    }

    Box(
        modifier = Modifier
            .focusRequester(focusRequester)
            .focusable()
    ) {
        content()
    }
}
```

**使用示例**：

```kotlin
// 使用FocusGroup的示例（已弃用）
@Composable
fun OldVideoListScreen() {
    FocusGroup(
        modifier = Modifier.fillMaxSize()
    ) {
        LazyVerticalGrid(
            columns = GridCells.Fixed(4),
            modifier = Modifier.fillMaxSize()
        ) {
            items(videos) { video ->
                VideoCard(
                    video = video,
                    modifier = Modifier.restorableFocus(
                        focusId = rememberSaveable { generateUniqueFocusableId() }
                    )
                )
            }
        }
    }
}
```

**rememberSaveable的优势**：
- 能够跨Activity重建保持状态
- 使用SavedStateRegistry自动保存和恢复
- 适用于需要持久化焦点状态的场景

### 2.3 焦点持久化对比

| 特性 | focusRestorer | FocusGroup（已弃用） |
|------|--------------|---------------------|
| 实现方式 | Modifier | Composable组件 |
| 状态保存 | 自动管理 | rememberSaveable |
| 跨Activity重建 | ❌ | ✅ |
| 使用复杂度 | 低 | 高 |
| 推荐使用 | ✅ | ❌ |

---

## 三、页面缓存机制分析

### 3.1 ViewModel缓存策略

**核心特点**：所有列表数据保存在ViewModel中，切换Tab时数据不会重新加载

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/RecommendViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/PopularViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/DynamicViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/ugc/UgcViewModel.kt`

**具体实现**：

#### 示例1：RecommendViewModel

```kotlin
// RecommendViewModel.kt
@KoinViewModel
class RecommendViewModel(
    private val recommendVideoRepository: RecommendVideoRepository
) : ViewModel() {
    private val logger = KotlinLogging.logger {}

    private val _recommendVideoList = mutableStateListOf<UgcItem>()
    val recommendVideoList: List<UgcItem> get() = _recommendVideoList

    private val _loading = mutableStateOf(false)
    val loading: State<Boolean> get() = _loading

    init {
        loadRecommendVideos()
    }

    fun loadRecommendVideos() {
        viewModelScope.launch {
            _loading.value = true
            try {
                val result = recommendVideoRepository.getRecommendVideos()
                _recommendVideoList.clear()
                _recommendVideoList.addAll(result)
            } catch (e: Exception) {
                logger.error(e) { "Failed to load recommend videos" }
            } finally {
                _loading.value = false
            }
        }
    }
}
```

#### 示例2：PopularViewModel

```kotlin
// PopularViewModel.kt
@KoinViewModel
class PopularViewModel(
    private val popularVideoRepository: PopularVideoRepository
) : ViewModel() {
    private val logger = KotlinLogging.logger {}

    private val _popularVideoList = mutableStateListOf<UgcItem>()
    val popularVideoList: List<UgcItem> get() = _popularVideoList

    private val _loading = mutableStateOf(false)
    val loading: State<Boolean> get() = _loading

    init {
        loadPopularVideos()
    }

    fun loadPopularVideos() {
        viewModelScope.launch {
            _loading.value = true
            try {
                val result = popularVideoRepository.getPopularVideos()
                _popularVideoList.clear()
                _popularVideoList.addAll(result)
            } catch (e: Exception) {
                logger.error(e) { "Failed to load popular videos" }
            } finally {
                _loading.value = false
            }
        }
    }
}
```

#### 示例3：DynamicViewModel

```kotlin
// DynamicViewModel.kt
@KoinViewModel
class DynamicViewModel(
    private val dynamicRepository: DynamicRepository
) : ViewModel() {
    private val logger = KotlinLogging.logger {}

    private val _dynamicList = mutableStateListOf<DynamicVideo>()
    val dynamicList: List<DynamicVideo> get() = _dynamicList

    private val _loading = mutableStateOf(false)
    val loading: State<Boolean> get() = _loading

    init {
        loadDynamics()
    }

    fun loadDynamics() {
        viewModelScope.launch {
            _loading.value = true
            try {
                val result = dynamicRepository.getDynamics()
                _dynamicList.clear()
                _dynamicList.addAll(result)
            } catch (e: Exception) {
                logger.error(e) { "Failed to load dynamics" }
            } finally {
                _loading.value = false
            }
        }
    }
}
```

**ViewModel生命周期**：
- 在Activity创建时通过Koin注入
- 在Activity销毁时自动清理
- 在Activity配置变更时保持不变

### 3.2 SavedStateHandle的使用

**重要发现：项目中没有使用SavedStateHandle**

搜索结果显示，整个项目中没有SavedStateHandle的使用。这意味着：
- 没有使用SavedStateHandle来保存临时状态
- 焦点持久化主要依赖focusRestorer和rememberSaveable
- 滚动位置持久化主要依赖ViewModel

### 3.3 持久化配置：DataStore

**核心特点**：使用DataStore持久化用户配置，如首页Tab选择

**实现位置**：
- `app/src/main/kotlin/dev/aaa1115910/bv/util/Prefs.kt`

**具体实现**：

```kotlin
// Prefs.kt
object Prefs {
    private val dsm = BVApp.dataStoreManager
    val logger = KotlinLogging.logger { }

    // 登录状态
    var isLogin: Boolean
        get() = runBlocking { dsm.getPreferenceFlow(PrefKeys.prefIsLoginRequest).first() }
        set(value) = runBlocking { dsm.editPreference(PrefKeys.prefIsLoginKey, value) }

    // 首页Tab选择
    var firstHomeTopNavItem: HomeTopNavItem
        get() = runBlocking {
            HomeTopNavItem.fromCode(
                dsm.getPreferenceFlow(PrefKeys.prefFirstHomeTopNavItemRequest).first()
            )
        }
        set(value) = runBlocking {
            dsm.editPreference(PrefKeys.prefFirstHomeTopNavItemKey, value.code)
        }

    // 用户设置
    var videoQuality: VideoQuality
        get() = runBlocking {
            VideoQuality.fromCode(
                dsm.getPreferenceFlow(PrefKeys.prefVideoQualityRequest).first()
            )
        }
        set(value) = runBlocking {
            dsm.editPreference(PrefKeys.prefVideoQualityKey, value.code)
        }

    // 代理设置
    var proxyArea: ProxyArea
        get() = runBlocking {
            ProxyArea.fromCode(
                dsm.getPreferenceFlow(PrefKeys.prefProxyAreaRequest).first()
            )
        }
        set(value) = runBlocking {
            dsm.editPreference(PrefKeys.prefProxyAreaKey, value.code)
        }
}
```

**使用示例**：

```kotlin
// HomeContent.kt
@Composable
fun HomeContent(
    modifier: Modifier = Modifier
) {
    // 从DataStore读取首页Tab选择
    val firstTab = remember { Prefs.firstHomeTopNavItem }
    var selectedTab by remember { mutableStateOf(firstTab) }

    Column(
        modifier = modifier.fillMaxSize()
    ) {
        TopNav(
            items = homeTopNavItems,
            isLargePadding = false,
            onSelectedChanged = { tab ->
                selectedTab = tab
                // 保存到DataStore
                Prefs.firstHomeTopNavItem = tab
            },
            onClick = { tab ->
                selectedTab = tab
                // 保存到DataStore
                Prefs.firstHomeTopNavItem = tab
            }
        )

        AnimatedContent(
            targetState = selectedTab,
            label = "home animated content",
            transitionSpec = {
                // 动画配置
            }
        ) { screen ->
            when (screen) {
                HomeTopNavItem.Recommend -> RecommendScreen()
                HomeTopNavItem.Popular -> PopularScreen()
                HomeTopNavItem.Dynamics -> DynamicsScreen()
            }
        }
    }
}
```

### 3.4 数据缓存架构

```
MainActivity
    ↓
MainScreen (Compose)
    ↓
AnimatedContent (Tab切换)
    ├─ HomeContent
    │   ├─ RecommendScreen (RecommendViewModel缓存数据)
    │   ├─ PopularScreen (PopularViewModel缓存数据)
    │   └─ DynamicsScreen (DynamicViewModel缓存数据)
    ├─ UgcContent
    │   └─ UgcRegionScaffold (UgcViewModel缓存数据和滚动状态)
    ├─ PgcContent
    │   └─ AnimeContent (AnimeViewModel缓存数据)
    ├─ LiveContent
    │   └─ LazyVerticalGrid (LiveViewModel缓存数据)
    └─ PersonalContent
        ├─ ToViewScreen (ToViewViewModel缓存数据)
        ├─ HistoryScreen (HistoryViewModel缓存数据)
        ├─ FavoriteScreen (FavoriteViewModel缓存数据)
        └─ FollowingSeasonScreen (FollowingSeasonViewModel缓存数据)

数据缓存层：
    ├─ RecommendViewModel (推荐视频列表)
    ├─ PopularViewModel (热门视频列表)
    ├─ DynamicViewModel (动态列表)
    ├─ UgcViewModel (UGC页面状态Map)
    └─ Prefs (DataStore持久化配置)
```

---

## 四、Activity配置分析

### 4.1 AndroidManifest.xml配置

```xml
<!-- app/src/main/AndroidManifest.xml -->
<activity
    android:name=".activities.MainActivity"
    android:banner="@drawable/ic_banner"
    android:exported="true"
    android:screenOrientation="landscape"
    android:theme="@style/Theme.BV.Splash">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
        <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
    </intent-filter>
</activity>
```

**关键配置说明**：
- `screenOrientation="landscape"`：固定横屏，避免配置变更导致的Activity重建
- 没有设置`configChanges`：Activity会在配置变更时重建
- 没有设置`launchMode`：使用默认的standard模式
- `LEANBACK_LAUNCHER`：Android TV启动器支持

### 4.2 MainActivity实现

```kotlin
// app/src/main/kotlin/dev/aaa1115910/bv/activities/MainActivity.kt
class MainActivity : ComponentActivity() {
    private val userRepository: UserRepository by inject()
    private val logger = KotlinLogging.logger {}

    override fun onCreate(savedInstanceState: Bundle?) {
        var keepSplashScreen = true
        installSplashScreen().apply {
            setKeepOnScreenCondition { keepSplashScreen }
        }
        super.onCreate(savedInstanceState)

        setContent {
            var isCheckingUserLock by remember { mutableStateOf(true) }
            var userLockLocked by remember { mutableStateOf(false) }

            LaunchedEffect(Unit) {
                val user = userRepository.findUserByUid(userRepository.uid)
                userLockLocked = user?.lock?.isNotBlank() ?: false
                logger.info { "default user: ${user?.username}" }
                isCheckingUserLock = false
                keepSplashScreen = false
            }

            BVTheme {
                if (isCheckingUserLock) {
                    // 加载中
                } else {
                    if (!userLockLocked) {
                        MainScreen()
                    } else {
                        UnlockUserScreen(
                            onUnlockSuccess = { user ->
                                logger.info { "unlock user lock for user ${user.uid}" }
                                userLockLocked = false
                            }
                        )
                    }
                }
            }
        }
    }
}
```

**关键点**：
- 使用ComponentActivity作为基类
- 使用Compose的setContent
- 没有重写onSaveInstanceState或onRestoreInstanceState
- 依赖ViewModel和remember来管理状态

### 4.3 其他Activity示例

```kotlin
// app/src/main/kotlin/dev/aaa1115910/bv/activities/video/VideoInfoActivity.kt
class VideoInfoActivity : ComponentActivity() {
    companion object {
        fun actionStart(
            context: Context,
            aid: Long,
            fromSeason: Boolean = false,
            fromController: Boolean = false,
            proxyArea: ProxyArea = ProxyArea.MainLand
        ) {
            context.startActivity(
                Intent(context, VideoInfoActivity::class.java).apply {
                    putExtra("aid", aid)
                    putExtra("fromSeason", fromSeason)
                    putExtra("fromController", fromController)
                    putExtra("proxy_area", proxyArea.ordinal)
                }
            )
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            BVTheme {
                VideoInfoScreen()
            }
        }
    }
}
```

---

## 五、Navigation配置

**重要发现：项目没有使用Jetpack Navigation**

项目没有使用Navigation Graph，而是采用以下方式：
- 使用Activity跳转进行页面导航
- 使用AnimatedContent进行Tab切换
- 使用Intent传递参数

**页面导航示例**：

```kotlin
// 从首页跳转到视频详情页
@Composable
fun VideoCard(
    video: UgcItem,
    onClick: () -> Unit = {}
) {
    val context = LocalContext.current

    Card(
        modifier = Modifier
            .clickable {
                // 使用Intent跳转到VideoInfoActivity
                VideoInfoActivity.actionStart(
                    context = context,
                    aid = video.id,
                    proxyArea = Prefs.proxyArea
                )
            }
    ) {
        // 视频卡片内容
    }
}
```

---

## 六、总结

### 6.1 页面滚动位置保存

| 页面类型 | 实现方式 | 滚动位置保存 | 状态保存位置 |
|---------|---------|------------|------------|
| UGC页面 | ViewModel | ✅ 保留 | ViewModel |
| Home页面 | remember | ❌ 丢失 | Composable |
| PGC页面 | remember | ❌ 丢失 | Composable |
| Live页面 | remember | ❌ 丢失 | Composable |

### 6.2 遥控器焦点持久化

| 实现方式 | 状态保存 | 跨Activity重建 | 推荐使用 |
|---------|---------|--------------|---------|
| focusRestorer | 自动管理 | ❌ | ✅ |
| FocusGroup | rememberSaveable | ✅ | ❌ |

### 6.3 页面缓存机制

| 数据类型 | 缓存方式 | 持久化方式 |
|---------|---------|-----------|
| 列表数据 | ViewModel | 不持久化 |
| 滚动位置 | ViewModel/remember | 不持久化 |
| 焦点位置 | focusRestorer/rememberSaveable | 不持久化 |
| 用户配置 | DataStore | 持久化 |

### 6.4 是缓存页面还是记忆后恢复

**数据层面**：ViewModel缓存数据，切换Tab时数据不会重新加载

**滚动位置**：
- UGC页面：缓存（ViewModel保存LazyGridState）
- Home页面：不缓存（remember创建，切换时丢失）

**焦点**：记忆后恢复（focusRestorer自动记录和恢复焦点位置）

**结论**：项目采用的是混合策略 - 数据通过ViewModel缓存，滚动位置部分缓存部分不缓存，焦点通过focusRestorer自动记忆和恢复。

---

## 七、相关文件路径

### 核心文件

- `app/src/main/AndroidManifest.xml` - Activity配置
- `app/src/main/kotlin/dev/aaa1115910/bv/activities/MainActivity.kt` - 主Activity
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/MainScreen.kt` - 主屏幕
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/HomeContent.kt` - 首页内容
- `app/src/main/kotlin/dev/aaa1115910/bv/screen/main/UgcContent.kt` - UGC内容

### ViewModel文件

- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/RecommendViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/PopularViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/home/DynamicViewModel.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/viewmodel/ugc/UgcViewModel.kt`

### 焦点管理文件

- `app/src/main/kotlin/dev/aaa1115910/bv/component/FocusGroup.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/component/TopNav.kt`
- `app/src/main/kotlin/dev/aaa1115910/bv/component/videocard/VideosRow.kt`

### 配置文件

- `app/src/main/kotlin/dev/aaa1115910/bv/util/Prefs.kt` - DataStore配置
- `app/src/main/kotlin/dev/aaa1115910/bv/BVApp.kt` - Application类

---

## 八、发现的问题和建议

### 问题1：Home页面滚动位置丢失

**问题描述**：
RecommendScreen、PopularScreen、DynamicsScreen使用`rememberLazyGridState`创建滚动状态，切换Tab时滚动位置会丢失。

**影响**：
- 用户在推荐列表滚动到某个位置，切换到热门Tab后再回来，滚动位置会重置到顶部
- 用户体验不佳

**建议**：
参考UgcContent的实现，将滚动状态保存在ViewModel中：

```kotlin
// 建议的HomeViewModel实现
class HomeViewModel : ViewModel() {
    private val _scrollStateMap = mutableMapOf<HomeTopNavItem, LazyGridState>()
    val scrollStateMap: Map<HomeTopNavItem, LazyGridState> get() = _scrollStateMap

    fun getScrollState(item: HomeTopNavItem): LazyGridState {
        return _scrollStateMap.getOrPut(item) { LazyGridState() }
    }
}

// 建议的HomeContent实现
@Composable
fun HomeContent(
    modifier: Modifier = Modifier,
    viewModel: HomeViewModel = viewModel()
) {
    var selectedTab by remember { mutableStateOf(HomeTopNavItem.Recommend) }

    Column(
        modifier = modifier.fillMaxSize()
    ) {
        TopNav(
            items = homeTopNavItems,
            isLargePadding = false,
            onSelectedChanged = { tab ->
                selectedTab = tab
            }
        )

        AnimatedContent(
            targetState = selectedTab,
            label = "home animated content"
        ) { screen ->
            // 从ViewModel获取滚动状态
            val gridState = viewModel.getScrollState(screen)

            when (screen) {
                HomeTopNavItem.Recommend -> RecommendScreen(gridState)
                HomeTopNavItem.Popular -> PopularScreen(gridState)
                HomeTopNavItem.Dynamics -> DynamicsScreen(gridState)
            }
        }
    }
}

// 修改后的RecommendScreen
@Composable
fun RecommendScreen(
    gridState: LazyGridState,
    viewModel: RecommendViewModel = viewModel()
) {
    val recommendVideoList by viewModel.recommendVideoList.collectAsState()

    LazyVerticalGrid(
        columns = GridCells.Fixed(4),
        state = gridState,  // 使用传入的滚动状态
        modifier = Modifier
            .fillMaxSize()
            .focusRestorer(focusRequester),
        contentPadding = PaddingValues(12.dp),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp),
    ) {
        items(
            items = recommendVideoList,
            key = { it.id }
        ) { video ->
            VideoCard(
                video = video,
                onClick = { /* 点击事件 */ }
            )
        }
    }
}
```

### 问题2：FocusGroup已弃用但仍在代码中

**问题描述**：
FocusGroup组件标记为@Deprecated，但仍然存在于代码库中。

**建议**：
- 完全移除FocusGroup组件
- 统一使用focusRestorer

### 问题3：没有使用SavedStateHandle

**问题描述**：
项目没有使用SavedStateHandle来保存临时状态。

**影响**：
- 在Activity被系统杀死后，一些临时状态可能丢失
- 焦点状态在极端情况下可能无法恢复

**建议**：
考虑在关键场景使用SavedStateHandle保存临时状态：

```kotlin
// 建议的ViewModel实现
@KoinViewModel
class RecommendViewModel(
    private val recommendVideoRepository: RecommendVideoRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    private val _recommendVideoList = mutableStateListOf<UgcItem>()
    val recommendVideoList: List<UgcItem> get() = _recommendVideoList

    private val _loading = mutableStateOf(false)
    val loading: State<Boolean> get() = _loading

    // 使用SavedStateHandle保存滚动位置
    private var scrollPosition by savedStateHandle.saveable("scroll_position") { 0 }

    init {
        // 恢复滚动位置
        if (savedStateHandle.contains("scroll_position")) {
            // 恢复滚动位置
        }
        loadRecommendVideos()
    }
}
```

### 问题4：没有使用Jetpack Navigation

**问题描述**：
项目没有使用Jetpack Navigation，使用Activity跳转进行页面导航。

**影响**：
- 页面导航逻辑分散
- 难以管理页面栈
- 难以实现页面间的数据传递

**建议**：
考虑引入Jetpack Navigation：

```kotlin
// 建议的Navigation实现
@Composable
fun BVNavGraph(
    navController: NavHostController = rememberNavController()
) {
    NavHost(
        navController = navController,
        startDestination = "home"
    ) {
        composable("home") {
            HomeScreen(
                onVideoClick = { aid ->
                    navController.navigate("video/$aid")
                }
            )
        }

        composable(
            route = "video/{aid}",
            arguments = listOf(
                navArgument("aid") { type = NavType.LongType }
            )
        ) { backStackEntry ->
            val aid = backStackEntry.arguments?.getLong("aid") ?: 0L
            VideoInfoScreen(aid = aid)
        }
    }
}
```

---

## 九、最佳实践建议

### 9.1 滚动位置保存

**推荐做法**：
- 使用ViewModel保存滚动状态
- 在ViewModel中维护滚动状态Map
- 在Composable中从ViewModel获取滚动状态

```kotlin
class MyViewModel : ViewModel() {
    private val _scrollStateMap = mutableMapOf<String, LazyGridState>()
    val scrollStateMap: Map<String, LazyGridState> get() = _scrollStateMap

    fun getScrollState(key: String): LazyGridState {
        return _scrollStateMap.getOrPut(key) { LazyGridState() }
    }
}

@Composable
fun MyScreen(
    viewModel: MyViewModel = viewModel()
) {
    val gridState = viewModel.getScrollState("my_screen")

    LazyVerticalGrid(
        columns = GridCells.Fixed(4),
        state = gridState,
        modifier = Modifier.fillMaxSize()
    ) {
        // 内容
    }
}
```

### 9.2 焦点持久化

**推荐做法**：
- 使用focusRestorer modifier
- 在可滚动容器上应用focusRestorer
- 避免使用FocusGroup

```kotlin
@Composable
fun MyScreen() {
    val focusRequester = remember { FocusRequester() }

    LazyVerticalGrid(
        columns = GridCells.Fixed(4),
        modifier = Modifier
            .fillMaxSize()
            .focusRestorer(focusRequester)  // 自动恢复焦点
    ) {
        // 内容
    }
}
```

### 9.3 数据缓存

**推荐做法**：
- 使用ViewModel缓存数据
- 使用mutableStateListOf保存列表数据
- 使用StateFlow或LiveData暴露数据

```kotlin
@KoinViewModel
class MyViewModel(
    private val repository: MyRepository
) : ViewModel() {
    private val _dataList = mutableStateListOf<MyItem>()
    val dataList: List<MyItem> get() = _dataList

    private val _loading = mutableStateOf(false)
    val loading: State<Boolean> get() = _loading

    init {
        loadData()
    }

    fun loadData() {
        viewModelScope.launch {
            _loading.value = true
            try {
                val result = repository.getData()
                _dataList.clear()
                _dataList.addAll(result)
            } catch (e: Exception) {
                // 错误处理
            } finally {
                _loading.value = false
            }
        }
    }
}
```

### 9.4 配置持久化

**推荐做法**：
- 使用DataStore持久化配置
- 使用单例对象管理配置
- 使用协程进行异步操作

```kotlin
object Prefs {
    private val Context.dataStore by preferencesDataStore("settings")

    val videoQualityKey = preferencesKey<Int>("video_quality")

    suspend fun getVideoQuality(context: Context): Int {
        return context.dataStore.data.map { preferences ->
            preferences[videoQualityKey] ?: 0
        }.first()
    }

    suspend fun setVideoQuality(context: Context, quality: Int) {
        context.dataStore.edit { preferences ->
            preferences[videoQualityKey] = quality
        }
    }
}

// 使用
@Composable
fun SettingsScreen() {
    val context = LocalContext.current
    var videoQuality by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        videoQuality = Prefs.getVideoQuality(context)
    }

    // UI
}
```

---

## 十、总结

本项目采用了混合的页面状态管理策略：

1. **数据缓存**：通过ViewModel缓存所有列表数据，切换Tab时数据不会重新加载
2. **滚动位置**：部分页面（UGC）通过ViewModel保存滚动位置，其他页面（Home）使用remember创建，切换时丢失
3. **焦点持久化**：通过focusRestorer自动记录和恢复焦点位置
4. **配置持久化**：通过DataStore持久化用户配置

这种策略在数据缓存方面表现良好，但在滚动位置保存方面存在不一致性。建议统一使用ViewModel保存滚动状态，以提供一致的用户体验。